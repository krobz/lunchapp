# A lunchapp

## Design Related

### Key Features:
1. User session initiation and management  
2. Restaurant submission  
3. Random restaurant selection at session end  

### Design Overview:
**Frontend**:<br />
A simple web application where users can join sessions, submit restaurants, and see results. <br />
Tech stack: **React** <br />
Due to I have few time to do this project, there are much todo in frontend. Tests are also pending. I plan to use sinon, chai, enzyme to 
do the test in frontend.

**Backend**: 
A server to handle requests such as creating sessions, joining sessions, submitting restaurants, and randomly selecting a restaurant. <br />
Teach stack: **Spring Boot** and **Java** (SDK version 17) <br />
Choose Spring Boot because it is easy to use and maintain with decoupling.

**Database**: To store session data, user data, and restaurant submissions. <br />
Teach stack: **PostgreSQL** (will be used by RDS in the future) and **Redis** (will be used as cache in the future) <br />
Why use SQL rather NoSQL: <br />
For this application, given the need for strong data integrity (e.g., ensuring a user cannot join an ended session, preventing duplicate submissions), 
ease of handling relationships, and the relatively simple data model, a SQL database is more convenient. But if we have millions of users, I think
could consider graph database (e.g., Amazon Neptune).

### Design Point for future improvements (most of them are not done in the current implementation due to time limit):
1. Consistency of the system:
Ensure that all users see the same list of restaurant submissions at any given time. This could be done by transaction in database.
If the system is distributed, we could consider use consensus algorithm (like Raft) to ensure consistency.

2. Availability of the system:
Use database replication to ensure availability of data. Here could use RDS read replica.

3. High concurrency requirements:
If there are many users in the same time, we should consider the high concurrency. Several ways could be considered: <br />
   - **Asynchronous Processing** is used in the code (see addRestaurantAsync), it helps improve the responsiveness of the application.
   - Using a scalable Database (like RDS or DynamoDB)
   - Using read-write separation: Master Instance handles all write request and slave instance (Read Replicas) handles for read request

## Api documentation
See step 7 in [Backend](#backend)

## Build & deployment

### Env requirements
JDK version: 17 <br />
mvn version: 3.8.1 <br />
npm version: 10.5.0 <br />
postgresql: 16.3.1 <br />
pgadmin: 8.6 <br />

### Backend
1. Create a database in postgresql.
2. Create a .env file in the backend project root directory (./backend), define you own apikey, user_name, user password. e.g.,
```
USER_NAME=postgres
USER_PASSWORD=123456
API_KEY=1234567890abcdef1234567890abcdef
```
You could choose to generate apikey in IAM of AWS (using creating access key then save)
3. Modify `mydatabase` to your own database name in `spring.datasource.url=jdbc:postgresql://localhost:5432/mydatabase`
under application.properties. Make sure database is connected in pgadmin.

4Navigate to the project root directory (where the pom.xml file is located) using:
Then, build the project with Maven using:
```
mvn clean install -DskipTests
```
6. Run the application using the .jar file with this command:
```
java -jar target/lunchapp-1.0-SNAPSHOT.jar
```
If you are running above in the first time, Hibernate will create tables automatically. 

7. API documentation is generated by `springdoc-openapi-ui`. You could find API documentation in
http://localhost:8080/swagger-ui.html after the backend is running.


### Frontend
1. Create a .env file under the project root directory (./frontend) and input API key. e.g.,
```
REACT_APP_API_KEY=1234567890abcdef1234567890abcdef
```
2. Navigate to the project root directory (./frontend), run 'npm install'
3. run 'npm start'







